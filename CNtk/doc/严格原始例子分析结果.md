# 严格按照书中例子的测试结果分析

## 测试代码（完全按照书中原始例子）

```swift
func shouldLoopAgain() -> Bool {
    // 只是一个例子
    return true
}

Task.detached {
    print("Task 1")
    var loop = true
    while loop {
        // 实际工作
        // ...
        loop = shouldLoopAgain()
    }
    print("All Done")
}

Task.detached {
    print("Task 2")
}
```

## 实际测试结果

```
Task 1
Task 2
```

**关键发现：Task 2 确实执行了！**

## 分析：为什么Task 2没有被阻塞？

### 1. 现代Swift运行时的改进

现代Swift运行时（Swift 5.5+）比书中描述的版本更智能：

- **线程池管理**：Swift并发调度器使用多个线程
- **任务分配**：两个`Task.detached`很可能被分配到不同的线程
- **抢占式调度**：操作系统级别的线程调度仍然在工作

### 2. 书中描述的条件

书中特别提到："**由于同样优先级的任务共用一个调度线程**"

这个条件在现代Swift中可能不总是成立，因为：
- 调度器会动态分配线程
- 系统有多个CPU核心
- 线程池大小通常等于CPU核心数

### 3. 何时会发生饥饿？

饥饿更容易在以下情况发生：

1. **系统资源紧张**：所有线程都被占用
2. **特定的调度策略**：强制任务在同一线程执行
3. **高负载情况**：大量并发任务竞争资源

## 结论

### 你的困惑是正确的！

1. **书中的理论是对的**：在特定条件下确实会发生饥饿
2. **现实情况更复杂**：现代Swift运行时有更好的调度策略
3. **不是绝对的**：饥饿不是必然发生的，而是可能发生的

### 关键理解

- `Task.detached` **不保证**每个任务都在独立线程
- 但也**不保证**所有任务都在同一线程
- 调度器会根据系统状态动态决定

### 书中例子的价值

书中的例子主要是为了：
1. **说明潜在风险**：无限循环可能导致饥饿
2. **教育最佳实践**：使用`await Task.yield()`
3. **理解调度原理**：Swift并发是协作式的

即使在现代运行时中饥饿不总是发生，但**避免无限循环仍然是最佳实践**。