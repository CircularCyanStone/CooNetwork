- 严格遵循SOLID设计原则
## 核心开发原则
**【重要】以Xcode编译结果为唯一标准**
- Xcode是Swift项目的权威开发环境
- 所有代码正确性判断以xcodebuild命令编译结果为准
- 忽略其他IDE的实时语法检查和警告提示
- 编译成功 = 代码正确，编译失败 = 需要修复

## 依赖状态判断准则
# 【核心原则】编译结果是依赖状态的唯一权威标准
# 编译成功 = 所有依赖已正确配置，无需额外干预
# 编译失败 = 存在真实的依赖问题，需要排查解决

### IDE使用规范
**禁止行为：**
- ❌ 依赖非Xcode IDE的实时语法检查（如红色波浪线）
- ❌ 基于IDE警告进行代码修改
- ❌ 使用非官方的Swift语法检查工具

**正确做法：**
- ✅ 使用Xcode作为主要开发环境
- ✅ 以xcodebuild编译结果验证代码正确性
- ✅ 只修复真实的编译错误，忽略IDE缓存问题

## 编译错误诊断标准流程

### 核心原则
**获取具体错误信息是解决问题的唯一前提**
- 拒绝基于猜测的修复
- 必须获得完整的编译错误信息
- 针对具体错误进行精准修复

### 【重要】IDE诊断信息处理原则
**Trae IDE诊断 vs Xcode编译错误的区别**
- ✅ **Xcode编译错误**：通过xcodebuild命令获得的真实编译失败信息，必须修复
- ❌ **Trae IDE诊断**：IDE实时语法检查产生的警告信息，应当忽略

**【技术原理】Trae IDE诊断问题的根本原因：**
- **不是缓存问题**：Trae IDE的"No such module"诊断并非缓存导致
- **编译环境缺失**：Trae IDE没有完整的Swift编译环境和插件支持
- **环境局限性**：只有Xcode和其命令行工具具备完整的Swift编译环境
- **技术差异**：Trae IDE无法提供与Xcode相同级别的Swift语言支持

**【关键教训】常见错误模式识别：**
- ❌ **"No such module 'UIKit'"诊断陷阱**：Trae IDE编译环境不完整导致，绝不是真实编译错误
- ❌ **"No such module 'Foundation'"诊断陷阱**：同样是编译环境问题，Foundation是Swift基础模块
- ❌ **添加不必要的import语句**：看到模块诊断错误就添加import，这是错误的反应

**正确处理方式：**
- ✅ 当收到诊断信息时，首先判断来源：是Trae IDE还是Xcode编译
- ✅ 如果是Trae IDE的"No such module 'UIKit'"等诊断，直接忽略
- ✅ 只有xcodebuild命令报告的编译失败才需要处理
- ❌ 禁止为了"修复"IDE诊断而执行clean、重新编译等操作
- ❌ 禁止将IDE缓存问题当作真实的编译错误处理
- ❌ **绝对禁止**：看到"No such module"诊断就添加import语句

### 标准诊断步骤

**3. 错误类型识别**
- **真实编译错误**：阻止项目构建，必须修复
- **IDE缓存警告**：不影响实际编译，可忽略
- **依赖问题**：通过编译命令确认，而非IDE提示

**4. 精准修复原则**
- ✅ 根据具体错误信息修复
- ❌ 禁止看到"No such module"就删除重建文件
- ✅ 先诊断再修复，避免破坏性操作

## 常见编译错误类型及解决方案

### 1. 方法调用参数错误（如缺少required参数）
- **现象**：missing argument for parameter 'xxx' in call
- **解决**：补充缺失的参数

### 2. 模块导入问题
- **现象**：No such module 'UIKit'、No such module 'Foundation'等
- **关键区分**：
  - **Trae IDE诊断**：在诊断消息中出现，通常是IDE缓存问题，直接忽略
  - **Xcode编译错误**：通过xcodebuild命令报告，需要真实修复
- **解决策略**：
  - ✅ 如果项目编译成功，忽略所有IDE诊断中的模块导入错误
  - ✅ 只有xcodebuild报告编译失败时才处理模块问题
  - ❌ 禁止为IDE诊断执行clean、重装依赖等操作

### 3. 语法错误
- **现象**：具体的语法错误提示
- **解决**：根据错误信息修复语法问题

### 【重要提醒】IDE诊断信息处理
**当收到包含"No such module"的诊断信息时：**
1. 首先确认信息来源：是诊断消息还是编译错误
2. 如果是诊断消息且项目能正常编译，直接忽略
3. 避免浪费时间进行不必要的clean和重新编译操作

## 【重要案例】错误处理模式总结

### 典型错误案例：盲目处理Trae IDE诊断信息
**错误行为记录（2024年12月）：**
- ❌ **错误触发**：收到Trae IDE的"Cannot find type 'iNtkRequest' in scope"等诊断信息
- ❌ **错误反应**：立即认为是真实编译错误，开始"修复"
- ❌ **错误操作1**：添加不必要的`@_exported import CNtk`语句
- ❌ **错误操作2**：修改正常工作的代码结构
- ❌ **错误操作3**：引入新的编译错误（"no such module 'CNtk'"）
- ❌ **错误循环**：为了修复引入的错误又进行更多不必要的修改

**根本问题分析：**
- 完全忽略了project_rules中的核心原则
- 没有区分Trae IDE诊断和真实Xcode编译错误
- 基于IDE诊断信息进行代码修改，违反了基本规范

**正确处理方式应该是：**
- ✅ 首先运行xcodebuild验证是否真的有编译错误
- ✅ 如果编译成功，直接忽略所有Trae IDE诊断信息
- ✅ 只有xcodebuild报告编译失败才进行修复

### 【新增规则】诊断信息处理强制检查
**收到任何"Cannot find type"、"No such module"等诊断信息时：**
1. **强制第一步**：运行`xcodebuild -workspace xxx.xcworkspace -scheme xxx build`
2. **判断标准**：编译成功 = 忽略所有诊断，编译失败 = 处理真实错误
3. **禁止行为**：在未验证编译状态前进行任何代码修改

### 【严重错误模式】AI助手常见违规行为
**【2024年12月最新案例】重复违规模式分析：**
- ❌ **错误触发**：收到用户提供的Trae IDE诊断信息（如"Cannot find type 'NtkLogger' in scope"）
- ❌ **错误反应**：立即认为需要"检查缺失的导入语句"，完全忽略project_rules
- ❌ **错误思维**："从诊断错误看，主要问题是NtkLogger、NtkActor、iNtkRequest等类型找不到，需要添加正确的导入语句"
- ❌ **根本问题**：完全没有阅读或理解project_rules中的核心原则

**【强制执行规则】AI助手必须遵循的处理流程：**
1. **收到诊断信息时的强制反应**：
   - ✅ 第一反应必须是："这是Trae IDE诊断信息，需要先验证编译状态"
   - ❌ 绝对禁止第一反应是："需要检查缺失的导入语句"
   - ❌ 绝对禁止第一反应是："需要添加正确的导入语句"

2. **强制验证步骤**：
   - 必须先运行xcodebuild命令验证编译状态
   - 编译成功 = 直接告知用户"诊断信息可以忽略，项目编译正常"
   - 编译失败 = 基于真实编译错误进行修复

3. **绝对禁止的行为模式**：
   - ❌ 看到"Cannot find type"就想添加import
   - ❌ 看到"No such module"就想修复模块导入
   - ❌ 基于诊断信息进行任何代码修改
   - ❌ 说"需要检查缺失的导入语句"这类话

**【问责机制】违规后果：**
- 每次违反此规则都会被记录为严重错误
- 必须在project_rules中添加新的案例记录
- 必须分析违规原因并制定防范措施

## 质量保证检查清单

### 编译验证清单
- [ ] 使用了标准的xcodebuild命令？
- [ ] 获取了完整的错误信息？
- [ ] 区分了IDE警告和真实编译错误？
- [ ] 收到诊断信息时是否先验证了编译状态？
- [ ] 是否避免了基于IDE诊断进行代码修改？
- [ ] 基于具体错误信息进行修复？
- [ ] 修复后重新验证编译结果？

### 开发规范清单
- [ ] 使用Xcode作为主要开发环境？
- [ ] 忽略了非Xcode IDE的语法提示？
- [ ] 以编译结果为代码正确性标准？
- [ ] 避免了不必要的依赖重装？
- [ ] 遵循了现代Swift开发最佳实践？

### 代码质量清单
- [ ] 遵循了SOLID设计原则？
- [ ] 保持了良好的代码注释？
- [ ] 维护了一致的代码风格？

## 文件创建规范

### 禁止创建的文件类型
**【重要】避免文件重复定义导致编译失败**

**禁止行为：**
- ❌ 直接创建README.md文件（容易与项目中其他README.md重名）
- ❌ 创建可能与现有文件重名的文档文件
- ❌ 在组件开发中主动创建文档文件

**正确做法：**
- ✅ 只创建必要的代码文件（.swift文件）
- ✅ 如需文档，使用代码注释或在代码中提供使用示例
- ✅ 避免创建可能导致Xcode构建冲突的文件
- ✅ 优先在代码文件头部添加详细注释说明用法

**原因说明：**
项目中可能存在多个README.md文件，Xcode在构建时会尝试将所有README.md复制到同一目标路径，导致"duplicate output file"错误，造成编译失败。
